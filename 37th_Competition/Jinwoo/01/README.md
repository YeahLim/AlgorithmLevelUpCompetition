# [백준 - 실버 2] 소가 길을 건너간 이유 (14465 번)

## ⏰  **time**

30분

## :pushpin: **Algorithm**

- 누적 합
- 슬라이딩 윈도우

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 연속된 K개의 신호등이 정상적으로 작동하도록 하기 위해서 최소 몇개의 신호등을 수리해야 하는지 구하는 문제이다.
- N: 횡단보도 개수
- K: 정상적인 신호등이 존재하도록 만들어야 하는 구간 크기
- B: 고장난 신호등의 개수


- 먼저, N개의 신호등 중에서 고장난 신호등의 번호를 입력받아 broken 리스트에 기록합니다. 고장난 신호등의 위치를 1로 표시하고, 그렇지 않은 신호등은 0으로 유지한다.


- 첫 번째 윈도우에서 K개의 신호등 중 고장난 신호등의 수를 계산한다.
- 이후, 슬라이딩 윈도우를 사용하여 한 칸씩 윈도우를 이동하면서, 이전 윈도우의 시작점을 제외하고 새로 추가되는 구간의 끝점을 고려하여 고장난 신호등의 수를 갱신한다. 
- 매번 구간이 이동할 때마다 고장난 신호등의 개수를 계산하고, 그중에서 최소 수리 횟수를 갱신한다.


## :black_nib: **Review**

### 슬라이드 윈도우
- 슬라이딩 윈도우는 배열이나 리스트와 같은 선형 데이터 구조에서 연속된 부분 구간(subarray)를 효율적으로 처리하기 위한 알고리즘 기법이다.
- 이 기법은 고정된 크기의 윈도우를 데이터 구조에 적용하고, 그 윈도우를 한 칸씩 이동하면서 연속된 구간을 처리하는 방식이다.
- 슬라이딩 윈도우 기법은 특정 구간에서의 계산을 빠르게 업데이트하면서 최적의 해를 찾는 문제에 자주 사용된다.

### 동작 방식
- 초기 윈도우 설정: 첫 번째 구간(윈도우)을 설정하여 계산합니다.
- 윈도우 이동: 윈도우를 한 칸씩 이동하면서, 이전 구간에서 제외되는 값과 새롭게 포함되는 값을 이용해 결과를 업데이트합니다.
- 결과 갱신: 이동할 때마다 계산된 결과를 저장하거나, 최적의 결과를 찾습니다.

슬라이딩 윈도우는 연속된 구간을 효율적으로 처리하는 데 유용한 알고리즘 기법이라는 것을 알게 되었다.