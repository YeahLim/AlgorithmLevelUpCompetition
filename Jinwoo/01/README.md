# [백준 - 실버 3] 1, 2, 3 더하기 (9095 번)

## ⏰  **time**

30분

## :pushpin: **Algorithm**

- 다이나믹 프로그래밍

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 테스트 케이스가 주어지고, 11 보다 작은 양의 정수 N이 입력이 됩니다.
- N이 1, 2, 3의 합으로 나타낼 수 있는 경우의 수를 구하는 문제입니다.

### 무작정 점화식으로 계산해보기
```commandline
- dp[1] = 1 / 1
- dp[2] = 2 / 1+1, 2
- dp[3] = 4 / 1+1+1, 2+1, 1+2, 3
- dp[4] = 7 / 1+1+1+1, 2+1+1, 1+2+1, 1+1+2, 3+1, 1+3, 2+2
- dp[5] = 13 / 1+1+1+1+1, 2+1+1+1, 1+2+1+1, 1+1+2+1, 1+1+1+2, 2+2+1, 2+1+2, 1+2+2, 3+1+1, 1+3+1, 1+1+3, 3+2, 2+3
- dp[6] = 26 / 1+1+1+1+1+1, ...

```
- 위 규칙을 확인해보면 `dp[x] = dp[x-1] + dp[x-2] + dp[x-3]`규칙이 반복되는 것을 확인할 수 있습니다.
- N은 11보다 작은 양수이므로 11까지 배열을 인덱싱 하여 해당 값들을 계산 후 반복문을 통해 테스트케이스 마다 N이 입력되면 해당 배열의 인덱스 값이 출력되도록 구현하였습니다.


## :black_nib: **Review**

- 위 점화식의 원리를 이해하기가 힘들어 인터넷 풀이를 찾아보았습니다.
```commandline
만약 N에 대해서 경우의 수를 찾을 때, 우리는 1,2,3만을 사용할 수 있으므로 다음 세가지 경우의 수가 있습니다.

(1) (N - 1) 에서 1 더하기 -> N-1을 만드는 경우의 수와 동일 = dp[N-1]
(2) (N - 2) 에서 2 더하기 -> N-2를 만드는 경우의 수와 동일 = dp[N-2]
(3) (N - 3) 에서 3 더하기 -> N-3을 만드는 경우의 수와 동일 = dp[N-3]

```