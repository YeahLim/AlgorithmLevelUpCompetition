# [백준 - 실버 5] 다리 놓기 (1010 번)

## ⏰  **time**

1시간 30분 이상

## :pushpin: **Algorithm**

- 수학
- 다이나믹 프로그래밍
- 조합론

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- M과 N개의 사이트가 있고 이들을 하나로 잇는 다리를 두는 경우의 수를 구하는 문제
- 다리는 서로 겹쳐질 수 없으며 한 사이트당 최대 하나의 다리를 놓을 수 있다.
- 이렇게 되면 최대 놓을 수 있는 다리의 수는 N개가 된다. (M이 N보다 크기 때문)

### 조합론 풀이방법

- 풀이를 찾아보니 조합 공식을 사용해서 푼 사람들이 많았다. 조합 공식이 뭘까?
- 조합론이란 집합 S와 자연수 k가 주어졌을 때, S의 (중복없는) k-조합은 S의 k개의 원소로 이루어진 부분집합을 일컫는다.
- 만약 S = {s1, s2, s3, ... , sn}가 원소의 유한집합이며 0<=k<=n이라면, S의 k-조합의 수는 이항 계수와 같다.

- 말이 좀 어렵다.. 쉽게 말하면 조합은 서로 다른 n개 중에 r개를 선택하는 경우의 수를 의미한다.
- M개의 지역에 N개의 다리를 놓을 수 있는 경우의 수를 구하는 것이기 때문에 이항계수 mCn 으로 표현할 수 있다.
- 이것은 **{M! / (M-N)! * N!}**의 풀이가 된다.
- 이해가 되지 않아 식을 세우기 위해 M/N 표를 그려보니 조합론 풀이식을 알 수 있었다.

## :DP Bottom-up 풀이방법

```commandline
T = int(input())
dp = [[0] * 30 for _ in range(30)]
for i in range(30):
    for j in range(30):
        if i == 1:
            dp[i][j] = j
        else:
            if i == j:
                dp[i][j] = 1
            elif i < j:
                dp[i][j] = dp[i-1][j-1] + dp[i][j-1]

for _ in range(T):
    N, M = list(map(int, input().split()))
    print (dp[N][M])
```

## :black_nib: **Review**

- 조합 공식을 처음 공부할 수 있었다.