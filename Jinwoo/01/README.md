# [백준 - 실버 2] 부분수열의 합 (1182 번)

## ⏰  **time**

1 시간 이상

## :pushpin: **Algorithm**

- 백트래킹
- 브루트포스 알고리즘

## ⏲️**Time Complexity**

$O(N * 2^N)$

## :round_pushpin: **Logic**

- N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 문제 입니다.
- 부분수열의 합이 S가 되는 경우를 구해야 하므로, 모든 부분 수열의 합을 구해보는 로직을 짜야 했습니다.

### 재귀함수를 통해 부분수열의 모든 경우의 수 구하기
- 도저히 모든 부분수열을 구하는 방법을 모르겠어서 인터넷에서 정답을 봤습니다.
- 저번 백트래킹 문제와 비슷하게 재귀를 통해 부분수열의 모든 경우를 구할 수 있었는데 동작 과정을 인간의 입으로 설명하기는 매우 어려운거 같습니다.
- 따라서 저는 직각삼각형을 그려 해당 로직을 이해할 수 있었습니다.

### 재귀 함수 호출을 하는 이유
- 재귀함수를 호출하는 이유는 부분수열의 모든 경우의 수를 보기 위해서 입니다.
- 사람이야 숫자를 쓰면서 순서를 바꿀 수 있지만, 컴퓨터의 배열 안의 숫자를 바꾸긴 어렵습니다.
- 따라서 숫자가 추가될 때 마다 재귀함수를 호출하여 모든 경우의 수를 여는 것이라고 이해했습니다. (이게 맞나?)
- 위와 같은 구조를 재귀 호출의 트리 구조라고 합니다.
- 함수가 호출되고 최대 깊이까지 탐색을 한다면 호출이 끝난 함수는 pop()을 통해 추가된 반복문의 숫자를 제거합니다.
- 해당 반복문의 시작 숫자를 제거 후엔 다음 반복문이 실행되며 새로운 조합의 수열을 조건과 비교할 수 있고 이로써 모든 경우의 수를 탐색할 수 있었던 것입니다.

## :black_nib: **Review**

- 이해하기 힘든 로직을 이해해서 뿌듯합니다.(나만의 방식이긴 하지만)
- 하지만 이 로직을 다른 문제에서 적용을 시키는것은 별개의 문제일거 같습니다.
- 처음에 이 문제를 풀이해야 할 땐 도저히 감을 못잡았기 때문에 앞으로 다른 부분수열을 구해야 할 때에 해당 로직을 적용시켜보고 싶습니다.