# [백준 - 실버 2] DFS와 BFS (1260 번)

## ⏰ **time**

1 시간 이상

## :pushpin: **Algorithm**

- 그래프 이론
- 그래프 탐색
- 너비 우선 탐색
- 깊이 우선 탐색

## ⏲️**Time Complexity**

$O(N^2)$

## :round_pushpin: **Logic**

- N: 정점(노드)
- M: 간선의 개수(엣지)
- V: 시작할 정점
- 위 정보와 정점간의 연결 정보가 주어지고, 해당 그래프를 DFS로 탐색할 경우와 BFS로 탐색할 경우를 출력하는 문제이다.

### **그래프 구현**

- 그래프를 구현하기 위해서는 **행렬을** 만들어야 한다.
- 이유는 아래 그림을 보면 이해가 될 것이다.
- 그래프를 구현하는 방법에는 **인접행렬(Adjacency Matrix)**과 **인접리스트(Adjacency List)** 방식이 있다.
    - 인접행렬(Adjacency Matrix): 2차원 배열로 그래프의 연결 관계를 표현하는 방식
    - 인접리스트(Adjacency List): 리스트로 그래프의 연결 관계를 표현하는 방식

### **인접행렬(Adjacency Matrix)**

노드의 개수가 `n`이라면 `n*n` 형태의 2차원 배열로 그래프의 연결 관계를 표현한다.

인접 행렬에서 행과 열은 노드를 의미하며, 각각의 원소들은 노드 간의 간선을 나타낸다.

`adj[i][j]` : `노드 i`에서 `노드 j`로 가는 간선이 있으면 1, 아니면 0

!https://velog.velcdn.com/images%2Ffalling_star3%2Fpost%2Fc20e690d-9674-49e7-b450-c3e15ed36268%2F22.JPG

- **가중치가 없는 무방향 그래프**
    - 연결되어 있는 경우 행렬에서 1의 값을 가지고, 연결되지 않은 경우 0의 값을 가진다. 두 개의 노드에서 간선이 동시에 연결되어 있기 때문에 인접 행렬이 대칭적 구조를 가진다.
- **가중치가 있는 유방향 그래프는 행렬**
    - 행렬에서 각 간선의 가중치 값이 저장된다. 이 경우 가중치가 0인 것과 간선이 없는 것이 구별돼야 한다.

### **01. 행렬 구현하기**

- 따라서 그래프를 구현하려면 행렬을 구현해야 한다.
- 리스트 컴프리헨션을 통해  (n+1)*(n+1) 행렬을 구현을 해주었다.

```python
#행렬 만들기
graph = [[0]*(N+1) for _ in range(N+1)]
```

- **1) 리스트 컴프리헨션**
    - 리스트 생성하기 기존에 배운 문법으로 1부터 10까지 정수를 순서대로 가지고 있는 리스트를 생성하는코드는 다음과 같다.
    - `[[0]*(N+1)]` 은 N이 3이라면 [[0,0,0,0]]을 출력합니다.
    - 리스트 컴프리헨션을 써주면 [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]행렬이 완성됩니다.

```python
graph = 0 1 2 3 행
	      0 0 0 0 0
        1 0 0 0 0
        2 0 0 0 0
        3 0 0 0 0
        열
```

- n*n으로 만들지 않은 이유는 정점간의 연결을 행렬에 표시할 때 편하게 하기 위해서이다. (배열에서 인덱스는 0번째부터 시작하기 때문)

```python
# 정점간의 연결 행렬에 표시
for i in range (M):
    a,b = map(int,input().split())
    graph[a][b] = graph[b][a] = 1
```

- 정점 1과 정점 2가 연결되어 있다는 정보가 입력된다면 그것을 행렬에 표기 하기 위해 0을 1로 바꿔준다.
- `graph[1][2] = graph[2][1] = 1`

```python
graph =   0 1 2 3 행
	      0 0 0 0 0
	      1 0 0 1 0
	      2 0 1 0 0
	      3 0 0 0 0
         열
```

### **02. 방문 리스트 만들기**

- BFS/DFS는 스택과 큐를 사용하여 구현한다.
- 이 때, 스택고 큐에 한번 들어갔던 노드는 다시 들어가면 안된다.
- 즉, 이 **노드가 스택과 큐에 들어갔던 적이 있는지 확인할 필요**가 있다. 이를 표현하기 위해 정점의 수만큼 방문 리스트를 만들어야 한다.

```python
#방문 리스트 행렬
visited1 = [0]*(N+1)
visited2 = visited1.copy()
```

- N이 3이라면, visited1 = [0,0,0,0]
- 만약 1번 노드가 스택에 들어간 적이 있다면 visited = [0,1,0,0] 이 될 것이다.

---

### **03. DFS 함수 만들기**

```python
#dfs 함수 만들기 (탐색을 시작하는 번호 V부터 탐색을 시작)
def dfs(V):
    visited1[V] = 1 # 방문처리
    print(V, end=' ')   # 1번 노드는 방문처리를 하였으므로 출력 => 1번 노드는 스택에 들어간 적이 있다.
    
    # 현재 노드와 연결되어 있는 노드 찾기
    for i in range(1, N+1):
        
        # 현재 노드와 연결이 되어 있고, 방문한 적이 없다면 재귀함수 호출 => 너비 탐색 전 깊이를 탐색한다.
        if graph[V][i] == 1 and visited1[i] == 0:
            dfs(i)
```

- 탐색하는 번호 V부터 탐색을 시작한다.
- 우선 시작할 정점을 방문 처리를 해준다.
- 여기서 방문처리를 하였다는 것은 스택으로 DFS를 구현하였을 때 스택에 들어간 적이 있다는 것과 동일하다. 따라서 방문 처리를 하였으므로 해당 간선(노드)를 출력해준다.
- 이후에 반복문을 돌려서 현재 노드와 연결되어 있는 노드를 찾는다.
- 행렬에 `if graph[v][i] == 1` 이라면 **현재 노드와 연결**이 되어 있다는 것을 의미한다.
- 그리고 방문처리가 되어있지 않다면 깊이 탐색의 대상이 되는 간선(노드)이다.
- 즉, **현재 간선(노드)와 연결된 노드 중 방문기록이 없는 간선(노드)를 찾는 코드**이다.
- 해당 조건에 해당이 된다면 재귀함수를 선언하여 준다.

---

### **DFS 과정 예시**

- **N: 정점(노드) = 4**
- **M: 간선의 개수(엣지) = 5**
- **V: 시작할 정점 = 1**
- **간선 정보**
    - 1 - 2
    - 1 - 3
    - 1 - 4
    - 2 - 4
    - 3 - 4

!https://blogfiles.pstatic.net/MjAyNDEyMjhfMjgy/MDAxNzM1MzIxMDYxNzA1.m8bxYP8fSBjesUvgQc2lhbpWiYWF1y3qmuPYZOD44X0g.G2QSrH9wH01XWC2pGgg8E-B9ZdVs7XbwHg0t0g_Ggzwg.PNG/SE-d4ec685a-886b-4cb6-a1d1-d84abe6a89b8.png?type=w1

- 위 그래프를 행렬로 표현하면 이렇게 그려질 것이다.

|  | 0 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 1 | 1 |
| 2 | 0 | 1 | 0 | 0 | 1 |
| 3 | 0 | 1 | 0 | 0 | 1 |
| 4 | 0 | 1 | 1 | 1 | 0 |

---

- **dfs(1) 호출 시작**
- 시작할 정점은 1 이므로 1이 먼저 방문처리가 된 후 출력이 될 것이다.
- **1**
- 그리고 현재 정점(노드)과 연결이 되어 있으며 방문처리가 되지 않은 정점(노드)들을 찾아보자.
- graph[1][i] 에서 찾아보면 **graph[1][2], graph[1][3], graph[1][4]** 이렇게 3개의 정점(노드)들이 보인다.
- 반복문에서 해당 조건을 돌릴 것이므로 **graph[1][2]**가 조건에 먼저 걸려 2번 정점(노드)로 재귀함수가 호출이 될 것이다. (깊이 탐색)

---

- **dfs(2) 호출 시작**
- 그 다음으론 2번 정점(노드)가 방문 처리가 되고 출력이 되게 된다.
- **1 => 2**
- 그리고 똑같이 현재 노드와 연결이 되어 있고 방문처리가 되지 않은 간선(노드)를 찾게 된다.
- 현재 방문된 간선을 확인해보면 **visited1 = [0, 1, 1, 0, 0]** 이다.
- 해당 조건을 가진 간선(노드)는 **graph[2][4]** 밖에 없다.
- 따라서 4번 정점(노드)로 재귀함수가 호출이 된다.

---

- **dfs(4) 호출 시작**
- 4번 재귀함수가 호출이 되면 마찬가지로 방문처리 후 4를 출력한다.
- **1 => 2 => 4**
- 그리고 현재 노드와 연결이 되어있으며 방문처리가 되지 않은 간선(노드)를 찾는다.
- 연결되어 있는 간선(노드)들은
- **graph[4][1], graph[4][2], graph[4][3]** 가 있으며
- 아직 방문 처리가 되어있지 않은 간선(노드)는 **graph[4][3]** 가 있다.
- 따라서 3번 정점(노드)로 재귀함수가 호출이 된다.

---

- **dfs(3) 호출 시작**
- 3번 재귀함수 호출이 되고 방문처리후 3을 출력한다.
- **1 => 2 => 4 => 3**
- 드디어 모든 정점들이 다 호출이 된듯 싶다.
- 우리는 시각적으로 그래프를 연상하며 정점이 전부 호출된것을 알 수 있지만 코드대로라면 역시 이번에도 현재 노드와 연결이 되어 있으며 방문 처리가 되지 않는 간선(노드)들을 찾는다.
- 연결되어 있는 간선(노드)들은
- **graph[3][1], graph[3][4]** 가 있지만, 방문처리가 이미 되어 있다.
- 여기가 이번 깊이의 끝이라 할 수 있겠다.
- 그렇게 dfs(3)의 재귀 함수가 종료가 된다.
- **dfs(3) 종료**

---

- dfs(4)도 **graph[4][3]** 말고 해당되는 간선(노드)가 없으므로 함수를 종료한다.
- **dfs(4) 종료**

---

- dfs(2)도 위와 동일하게 종료된다.
- **dfs(2) 종료**

---

- dfs(1)도 비록 다음 반복문의 조건에 해당되는 간선(노드)들이 있긴 했지만 이전 재귀함수의 호출에서 **graph[1][3], graph[1][4]** 가 방문 처리가 되었다.
- 따라서 dfs(1)도 함수가 종료된다.
- **dfs(1) 종료**

---

- 따라서 DFS로 호출할때 출력되는 간선의 순서는 다음과 같다.
- **1 => 2 => 4 => 3**

---

- **04. BFS 함수 만들기**
- 출처 입력
- BFS는 선입선출인 **Queue**를 사용한다. (선입 선출)

```python
#bfs 함수 만들기
def bfs(V):

    # queue에 탐색할 노드 V를 삽입
    queue = [V]
    visited2[V] = 1 # 방문처리

    # 반복문을 통해 queue에 노드 정보가 없을때까지(탐색이 끝날때 까지) 반복해주자.
    while queue:

        # 방문 노드 제거 후 출력
        V = queue.pop(0)    # queue의 0번쨰 요소를 돌려준 후 삭제 (선입 선출)
        print(V, end = ' ')
        
        # 현재 간선(노드)와 연결되어 있고, 방문처리가 되지 않은 간선(노드) 찾기
        for i in range(1, N+1):
            if(visited2[i] == 0 and graph[V][i] == 1):
                queue.append(i) # 해당 조건이 있으면 queue에 넣은 후
                visited2[i] = 1 # 방문처리
```

- 탐색 시작 간선(노드)가 주어지면 해당 노드를 queue에 넣고 방문처리를 해준다.
- 그리고 while문을 통해 **queue에 노드 정보가 없을 때까지(탐색이 끝날 때까지) 아래 과정을 반복**한다.
    - **queue에 노드 정보가 있다면**, 선입선출 해준 후(**queue의 0번째 요소 제거 후**)
    - **현재 간선(노드)와 연결되어 있고, 방문처리가 되지 않은 간선(노드)를 찾아 queue에 넣고 방문처리**를 해준다.
- 이와 같은 과정을 반복하면 무슨 일이 일어날까?
- 역시 예시를 들어 확인해보자.

---

### BFS 과정 예시

- 위 DFS의 예시를 그대로 BFS로 재현해보자.
- **N: 정점(노드) = 4**
- **M: 간선의 개수(엣지) = 5**
- **V: 시작할 정점 = 1**
- **간선 정보**
    - 1 - 2
    - 1 - 3
    - 1 - 4
    - 2 - 4
    - 3 - 4

!https://blogfiles.pstatic.net/MjAyNDEyMjhfMjgy/MDAxNzM1MzIxMDYxNzA1.m8bxYP8fSBjesUvgQc2lhbpWiYWF1y3qmuPYZOD44X0g.G2QSrH9wH01XWC2pGgg8E-B9ZdVs7XbwHg0t0g_Ggzwg.PNG/SE-d4ec685a-886b-4cb6-a1d1-d84abe6a89b8.png?type=w1

- 위 그래프를 행렬로 표현하면 이렇게 그려질 것이다.

|  | 0 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 1 | 1 |
| 2 | 0 | 1 | 0 | 0 | 1 |
| 3 | 0 | 1 | 0 | 0 | 1 |
| 4 | 0 | 1 | 1 | 1 | 0 |

---

- **bfs() 호출**
    - 시작 간선(노드) queue에 추가
    - **queue = [1] / visited2 = [0, 1, 0, 0, 0]**
    - while을 통해 queue에 노드 정보가 없을 때까지(탐색이 끝날 때까지) 아래 과정을 반복해주자.

---

- while 첫번째 반복

```python
# 방문 노드 제거 후 출력
        V = queue.pop(0)    # queue의 0번쨰 요소를 돌려준 후 삭제 (선입 선출)
        print(V, end = ' ')
```

- 해당 코드로 queue에 있던 노드 정보를 선입선출로 꺼내 (0번째 요소를 꺼내) V 에 넣고 출력한다.
- **1**
- 이렇게 되면 1은 queue 에서 V로 요소를 돌려준 후 삭제된다.
- **queue = [] / visited2 = [0, 1, 0, 0, 0]**
- 그리고 현재 간선 V와 연결된 간선(노드) 이면서, 방문 처리가 되지 않은 간선(노드)를 찾아 queue에 선입선출로 넣는다.

```python
# 현재 간선(노드)와 연결되어 있고, 방문처리가 되지 않은 간선(노드) 찾기
        for i in range(1, N+1):
            if(visited2[i] == 0 and graph[V][i] == 1):
                queue.append(i) # 해당 조건이 있으면 queue에 넣은 후
                visited2[i] = 1 # 방문처리
```

- 현재 graph[1][i] 중 조건에 해당되는 간선(노드)들은 **graph[1][2], graph[1][3], graph[1][4]** 가 있다.
- 따라서 2, 3, 4 간선(노드)들이 추가가 된다.
- 그리고 추가된 간선(노드)들은 방문 처리가 되게 된다.
- **queue = [2, 3, 4] / visited2 = [0, 1, 1, 1, 1]**
- 이렇게 첫번째 while 반복이 종료된다.

---

- while 두번째 반복
- queue에 요소들이 추가되어 2, 3, 4가 있으므로 두번째 반복문이 시작된다.
- queue의 0번째 요소 '2' 가 pop이 된 후 출력이 된다.
- **queue = [3, 4] / visited2 = [0, 1, 1, 1, 1]**
- **1 => 2**
- 그리고 현재 간선(노드) V = 2 와 연결되어 있는 간선(노드)들은 **graph[2][1], graph[1][4]** 가 있지만 이미 방문처리가 되어 있으므로 queue에 값이 추가되지 않고 반복문이 종료가 된다.

---

- while 3번째 반복
- 역시 queue에 값이 남아 있으므로 3번째 반복이 시작된다.
- 이번에 queue의 0번째 요소 '3' 이 pop이 된 후 출력이 된다.
- **queue = [4] / visited2 = [0, 1, 1, 1, 1]**
- **1 => 2 => 3**
- 현재 간선(노드) V = 2 와 연결되어 있는 간선(노드)들은 **graph[3][1], graph[3][4]** 가 있지만 이미 방문처리가 되어 있으므로 queue에 값이 추가되지 않고 반복문이 종료가 된다.

---

- while 4번째 반복
- queue에 값이 남아 있으므로 4번째 반복이 시작된다.
- 이번에 queue의 0번째 요소 '4' 이 pop이 된 후 출력이 된다.
- **queue = [] / visited2 = [0, 1, 1, 1, 1]**
- **1 => 2 => 3 => 4**
- 현재 간선(노드) V = 4 와 연결되어 있는 간선(노드)들은 **graph[4][1], graph[4][2], graph[4][3]** 가 있지만 이미 방문처리가 되어 있으므로 queue에 값이 추가되지 않고 반복문이 종료가 된다.

---

- 어라? queue에 더이상 값이 남아있지 않다.
- 따라서 while 문이 종료가 되고 bfs() 또한 종료가 되게 된다.

---

- 이번 예시에서는 깊이가 더 있는 노드가 없어 중간에 queue에 값이 한번밖에 추가되지 않았지만
    - == for문을 한번밖에 사용하지 않았지만
    - == 2중 반복문이 한번밖에 사용되지 않았지만
- queue의 선입선출 특성을 통해 값이 추가 되더라도 너비를 우선적으로 탐색할 수 있는 BFS 함수의 예시를 경험할 수 있었다.
- 어찌됐든 BFS로 탐색을 하게될 경우 순서는 다음과 같다.
    - **1 => 2 => 3 => 4**

---

## :black_nib: **Review**

이번 문제 풀이를 통해 BFS, DFS가 무엇인지 조금은 알 수 있을거 같다.