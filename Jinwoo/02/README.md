# [백준 - 실버 4] 요세푸스 문제 (1158 번)

## ⏰  **time**

20분

## :pushpin: **Algorithm**

- 구현
- 자료규조
- 큐

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 1번부터 N번까지 원을 이루며 앉아있고, 순서대로 K번째 사람을 제거했을때 제거되는 순서를 출력하는 문제이다.
- N 까지의 배열을 만든 후 num이라는 인덱스 정보를 만들어 num이 K-1의 값이 되었을때 숫자를 answer 배열에 넣어주었다.
- 시간복잡도 때문에 배열의 숫자를 제거하지 않고 num = num % len(N_arr)를 통해 나머지 값으로 바꿔주어 다음 제거할 숫자를 찾을수 있도록 풀이를 진행하였다. 

## :black_nib: **Review**

- 요세푸스 문제는 유대인 역사가 플라비우스 요세푸스가 겪은 경험을 바탕으로 만들어진 문제라고 한다.
- 1부터 41까지의 숫자를 원형으로 배치한 다음, 1부터 시작하여 다음 숫자로 넘어가며 숫자를 하나 건너뛰고 다음 숫자를 제거하는 것을 반복하여 마지막에 남는 숫자를 구하는 문제이다.
- 마지막에 남는 수만 알아내면 되는 경우와, 제거된 수의 순서도 알아내야 하는 경우의 효율적인 풀이가 다르다고 한다.


## 큐를 이용한 풀이 방법

원형 연결리스트를 사용하는 방법과 유사하게 문제의 상황을 그대로 시뮬레이션하는 방법이지만, 원형인 문제 상황을 일자로 펴서 구현하는 방식이다. 이를 효율적으로 구현하기 위해 다음과 같이 큐를 활용하게 된다.
큐에 1부터 n까지 작은 수부터 순서대로 삽입한다.
다음을 n-1회 반복한다.
k-1회 큐에서 수를 꺼낸 다음 곧바로 다시 삽입한다.
큐에서 수를 하나 꺼낸다. 이 수가 다음으로 제거되는 수이며, 다시 삽입하지 않는다.
큐에 남아있는 수가 마지막에 남는 수이다.

사실상 연결리스트를 활용한 방법과 동일한 원리로 작동하므로 동일한 최적화 방식 역시 적용할 수 있고, 시간복잡도 역시 O(nk)이다.