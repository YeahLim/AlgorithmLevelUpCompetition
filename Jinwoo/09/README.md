# [백준 - 실버 5] 수 정렬하기 2 (2751번)

## ⏰  **time**

1시간 이상

## :pushpin: **Algorithm**

정렬

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 첫번째 줄에 입력받을 줄의 갯수 N을 입력받는다.
- 두번째 줄부터 비교할 숫자 정보들을 N번만큼 입력을 받는다.
- sys.stdin.readline() 을 통해 입력을 받고, 여러번 입력을 받아야 하므로 반목문 for문을 통해 N번만큼 반복하여 입력을 받는다. 입력받은 정보는 num_list.append를 통해 리스트에 집어넣는다.
- 정보를 입력받은 숫자 리스트 num_list를 .sort() 함수를 통해 오름차순으로 정렬한다.
- 이제 반복문을 통해 리스트들의 숫자정보를 처음부터 끝까지 현재의 인덱스 값 num_list[i] 값과 이전의 인덱스 값 num_list[i-1]를 비교하여 들어있는 정보값이 다르다면 중복값이 아니므로 출력을 하도록 할것이다.
- 하지만 0번째 인덱스는 그 이전의 인덱스와 비교할 정보가 없으므로 반복문 전에 인덱스 0번값을 미리 출력해준 후 for문을 i 가 1부터 시작하도록 한다.


## :black_nib: **Review**

- 사실 이번 문제는 오름차순을 정렬 후 리스트를 set()함수를 통해 중복값을 제거하면 되는 간단한 문제이다.
- 하지만 나는 set()의 동작 원리를 모르고 직접 한번 코딩을 해보자! 해서 내가 가진 지식으로 set()함수를 사용하지 않고 풀이를 시작하였다.


## 첫번째 문제풀이 시도 (오류: 시간초과)

    N = int(input())                                        # 입력받을 줄 갯수
    => 1
    num_list = []                  
    => 1
    
    for i in range(N):  
    N                                       # 두번째 줄부터 N+1까지 비교할 숫자들 입력
        num_list.append(int(input()))
       1
    
    => N*1 => N
    
    num_list.sort()
    => N*logN
    
    
    for check in range(1, N+1):
    =>N+1 => N
    
        if N == 1:
       1
            break
          1
       => 1*1 => 1
       
        if check >= len(num_list):
       1
            break
          1
       => 1*1 => 1
    
        if num_list[check-1] == num_list[check]:
       1
            del num_list[check]
       => N
       =>N
    
    => N*(1+1+N) => N^2 + 2N => N^2
    
    for i in num_list:
        print(i)
    => N
    
    
    전체)
    (입력 받기) + (배열 생성하기) + (입력하는 숫자 저장하기) + (정렬하기) + (중복 제거하기) + (출력하기)
    1   +   1   +   N      +   NlogN   +   N^2   +   N
    = 2+2* N + NlogN + N^2
    = 1 + N + NlogN + N^2
    = N^2
    O(N) = N^2
    
    이떄 N의 최대값 = 100만
    
    O(100만) = 100만*100만 > 2천만(2초)
    => 안돌아감ㅠ

 위 내용은 시간초과 오류가 나서 시간 복잡도를 수현이화 함께 계산을 해보았다.
 드디어 나도 시간복잡도를 생각하며 코딩을 해야하는 레벨이 온것이다.

 처음에는 while문을 써서 풀이를 하였는데 while문을 빠져나오지 못하는 것인줄 알았다.
 하지만 for문으로 바꿔도 결과는 똑같이 시간초과가 나왔다.

 보다시피 중복값을 확인하는 반복문의 시간복잡도는 N인데 그 안에 del list() 라는 함수를 사용하여 시간 복잡도가 N^2이 되어버렸다
 
*del 함수가 왜 시간복잡도가 N인가?

리스트는 인덱스 값이 삭제될때 삭제된 공백을 메꾸고 리스트를 붙이기 위해 삭제된 값의 다음 인덱스 값을 하나씩 앞으로 당겨오며 진행된다.
만일 N이 100만개가 들어왔다면, del 함수가 구동되는 순간마다 100만번의 연산이 들어가게 되는 것이다.
즉 이거는 입력값이 무한대로 들어온다면 del 구동또한 무한이 되므로 시간복잡도는 N으로 계산된다.

 파이썬의 1초당 연산속도는 2천만번이라고 들었다.
 이 문제에서 주어지는 입력값의 최대 범위는 100만 이다.
 100만 * 100만은 2천만번이 훨씬 넘어버리므로 시간초과가 났던 것이었다.

따라서 리스트의 인덱스를 삭제하는 방법이 아닌 이전값과 현재값을 비교 후 다르다면 바로 출력하게끔 풀이방법을 바꾸었다.

허나 이렇게 바꿔 코딩해도 시간초과 오류가 났다...
이유를 찾다보니 아무리 생각해봐도 입력이 문제가 있는거 같았다.
전에 for문을 통해 여러번 입력 받을 경우 시간복잡도 때문에 input()으로 받지 말고 readline()으로 받으라는 글이 기억나 바꿨더니 바로 해결이 되었다.
input()과 readlint() 의 시간복잡도 차이도 공부해봐야겠다.
