# [백준 - 실버 3] 두 수의 합 (3273 번)

## ⏰  **time**

30분

## :pushpin: **Algorithm**

정렬
두 포인터

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- N만큼의 수열을 입력받고, 값의 두 합이 X의 수에 맞는 경우의 수를 출력하는 문제이다.
- 두 경우의 수 i, j는 겹치지 않는다. (1<i<j<n) 즉, 중복된 인덱스 값을 생각할 필요는 없다. (i != j)
- 그리고 정렬을 하여 주어진 X값과 두 인덱스 값의 합을 비교하여 경우에 따라 왼쪽과 오른쪽의 포인터를 이동시키며 경우를 count 해야겠다고 생각했다.
- 따라서 두 인덱스 값의 합이 X와 같다면 cnt를 올려주고 왼쪽 포인터 인덱스 값을 +1 시켜준다. (오른쪽 인덱스 값을 -1 시켜줘도 상관 없음. 어찌됐건 수를 센 경우는 넘겨야 하기 때문.)
- 그리고 합이 X보다 작다면 왼쪽 인덱스에 +1을, 합이 X보다 작다면 오른쪽 인덱스를 -1를 해준다.
- 계속 하다보면 왼쪽 인덱스 값이 오른쪽 인덱스 보다 커지는 순간이 발생할 것이고, 그 경우 반복문이 종료된 후 cnt 값을 출력 시킨다.

## :black_nib: **Review**

- 양쪽 인덱스 값을 기준점(포인터)로 잡아 X값과 비교하며 경우의 수를 구하는 문제였다.
- 조금만 생각해보면 정렬하여 값에 따라 포인트를 변경하여 경우의 수를 구하면 연산을 줄이며 풀이를 할 수 있었다.