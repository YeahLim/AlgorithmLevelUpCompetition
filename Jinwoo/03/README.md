# [백준 - 실버 4] 점수를 최대로 (29767 번)

## ⏰  **time**

30분

## :pushpin: **Algorithm**

- 그리디 알고리즘
- 정렬
- 누적합

## ⏲️**Time Complexity**

$O(NlogN)$

## :round_pushpin: **Logic**

- 학생들이 각 교실을 지나갈 때 교실의 점수를 최대화 하는 문제입니다.
- 따라서 누적합을 계산하여 각 교실의 점수 합을 최대화를 하는 방식으로 문제풀이를 진행하였습니다.

### 누적합 계산

- 우선 `교실의 개수: N`과 `학생의 수: K`를 입력받습니다.
- 그리고 각 교실의 점수 계수를 `data` 리스트에 담습니다.
```commandline
dp = [0] * N    # 배열을 활용하여 누적합 저장
dp[0] = data[0]

# 교실 1번부터 i + 1 번 까지의 점수 계수의 누적합
for i in range(1, N):
	dp[i] = dp[i-1] + data[i]
```

- dp 배열을 사용하여 각 교실의 점수 계수의 누적합을 저장하였습니다.
- 학생들이 교실을 방문할 때는 연속된 교실 구간의 점수를 계산해야 하므로 누적합 배열에서 상위 K개의 값을 선택하여 점수의 합을 최대화 하는 방법으로 풀이를 진행하였습니다.

```commandline
dp.sort(reverse=True)
```
- 그리고 누적합 배열을 정렬해서 상위 K개의 값을 선택하도록, 점수 계수가 큰 교실들을 우선적으로 포함하도록 최대화 하였습니다.


## :black_nib: **Review**

- 누적합 배열을 활용하여 각 교실간의 점수 합을 구하는 법을 알 수 있었다.
