# [백준 - 실버 2] 좌표 압축 (18870 번)

## ⏰  **time**

1시간 이상

## :pushpin: **Algorithm**

정렬
값 / 좌표 압축

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 첫번째 줄에 입력받을 좌표 개수 N을 선언한다.
- 그리고 좌표를 공백으로 구분되어 입력을 받는다. 입력받은 값들은 순서대로 리스트(N_list)에 저장한다.
- set()함수로 중복값을 제거한 후, sort()함수로 오름차순으로 만들어 좌표값들을 정렬한 리스트(Set_list)를 선언한다.
- 이렇게 되면 Set_list의 인덱스 값이 좌표정렬한 값이 된다.
- 순서대로 출력을 해주어야 함으로 N_list의 첫번째 값이 무엇인지에 따라 Set_list의 인덱스 값을 출력해주어야 한다.
- 따라서 딕셔너리를 사용하여 {Set_list[i]:i for i in range(len(Set_list))} 즉 Set_list[0] = 0, Set_list[1] = 1, ... Set_list[i] = i 로 값을 출력하기 위해 딕셔너리를 활용하여 '키:값'인 형태로 선언한다.
- 이렇게 선언한 딕셔너리를 for문을 통해 입력받은 좌표값 순서대로 N_list의 값을 집어넣어 출력한다.

## :black_nib: **Review**

- 이번 문제풀이는 정말 어려웠다... 일단 처음에 문제가 잘 이해가 되지 않았다.
- 이해하고 나서 받은 좌표값들을 중복값을 제거 후 오름차순으로 정렬하면 적힌 순서가 출력 해야될 좌표 압축값이란 것을 알았다.

## 첫번째 문제풀이 오류 (시간초과)

```
    N = int(input())                                                        # 입력할 좌표 갯수 N 입력
    
    N_list = list(map(int, input().split()))                                # X(n) 좌표 리스트에 입력, split()을 통해 공백 한 칸으로 구분
    setN = list(map(int, set(N_list)))                                      # 중복값을 제거한 setN 리스트, N_list와 값을 비교한 후 작은값이 있을경우 count 리스트에 +1 을 해주기 위해 존재
    count_list = [0] * N                                                    # N의 count 리스트를 만들어준다.
    
    for i in range(N):
        for j in range(len(setN)):
            if (setN[j] < N_list[i]):
                count_list[i] += 1
    
    print(count_list)
```

- 보다시피 입력받는 좌표값의 범위가 -10^9 부터 10^9 까지이다.
- 하지만 for문을 2중으로 사용하며 리스트의 값을 비교하였기에 시간복잡도가 N^2이 되어버렸다.
- 이 문제를 해결하기 위해 검색하여 딕셔너리란 것을 알아내었다

## 딕셔너리

- 딕셔너리는 중괄호{} 로 선언하며, '키:값'형태로 쉼표로 연결해서 만든다.

`    user = {"name": "사용자", "email": "user@test.com", "age": 25}
`
- 위 예시와 값이 '키:값' 형태로 선언할 수 있으며 키값을 입력하면 지정한 값을 출력하는 형태이다.
- 이 형태는 시간복잡도가 O(N)이므로 성공적으로 문제풀이를 진행할 수 있었다.