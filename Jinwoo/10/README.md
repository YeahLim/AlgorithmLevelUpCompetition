# [백준 - 브론즈 1] 수 정렬하기 3 (10989번)

## ⏰  **time**

1시간 이상

## :pushpin: **Algorithm**

정렬

## ⏲️**Time Complexity**

$O(N+k)$

## :round_pushpin: **Logic**

- 첫번째 줄에 입력받을 줄의 갯수 N을 입력받는다.
- 두번째 줄부터 비교할 숫자 정보들을 N번만큼 입력을 받는다.
- sys.stdin.readline() 을 통해 입력을 받고, 여러번 입력을 받아야 하므로 반목문 for문을 통해 N번만큼 반복하여 입력을 받는다. 입력받은 정보는 num_list.append를 통해 리스트에 집어넣는다.
- 정보를 입력받은 숫자 리스트 num_list를 .sort() 함수를 통해 오름차순으로 정렬한다.
- 그 후 for문을 통해 출력하면 될 줄 알았건만 메모리 제한이 있어 오류가 뜬다.
- 검색해보니 계수정렬을 통해 문제를 풀어봐야 한다고 한다. 하지만 나는 계수정렬이 뭔지 모른다.
- 공부 후 나름대로 정리를 해서 풀어봤다.

## 계수 정렬 이란

- 계수정렬은 카은트할 배열을 선언하고, 정렬할 배열 요소가 몇개 있는지 카운드 배열 각 인덱스에 담는다.
- 데이터의 크기가 한정되어 빠르게 동작해야 할 때 사용된다.


    arr = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
    cnt = [0] * (max(arr) + 1) #카운트 할 배열

    for i in range(len(arr)):
      cnt[arr[i]] += 1 # for문을 돌며 각 데이터에 해당하는 인덱스 값을 +1 한다
    
    for i in range(len(cnt)): #len(cnt)는 10이다
      for _ in range(cnt[i]):#cnt의 인덱스 하나를 돈다.
        print(i, end = " ") #i를 cnt의 값만큼 반복 출력하고 빠져나와 그 다음 i+1번째 인덱스로 이동한다위 블로그글은 저작권법에 의해서 보호됩니다. 무단 전재 또는 복제시 관련법에 따라 처벌될 수 있습니다. 블로그 원본 글:https://kill-xxx.tistory.com/entry/python-계수정렬
    출처: https://kill-xxx.tistory.com/entry/python-계수정렬 [개발바닥 꼬순내:티스토리]

즉 입력받을 경우의 숫자종류의 서랍을 리스트로 만들어 입력받는 배열에 있는 숫자들을 각각의 서랍에 하나씩 추가하는 형식이다.
우리가 숫자를 셀때 5가 3개, 3이 2개, 1이 4개... 이렇게 세는것과 같다고 생각한다.

- 그래서 이 계수 정렬을 활용하여 최대 입력수가 100만 이므로 100만 + 1(0포함)의 서랍 리스트를 선언해주고 (arr)
- for문을 N만큼 돌려 입력받는 숫자를 인덱스 값으로 돌려 각 숫자의 서랍을 1씩 증가시켰다.
- 그 후 반복문 2개를 사용하여 arr의 길이까지 반복하여 인덱스에 들어있는 값이 0이 아니면 들어있는 숫자만큼 반복하여 인덱스 값을 출력하는 풀이방법으로 진행하였다.


## :black_nib: **Review**

- 계수정렬의 평균 시간 복잡도는 O(N+k)라고 한다. 여기서 k는 정렬을 수행할 배열의 가장 큰 값이라고 할 수 있다.
- 계수 정렬의 특징은 데이터 크기가 한정되어 있을 때 매우 빠르게 동작한다는 특징이 있다.

- 계수 배열의 단점은 배열의 최대값이 매우 클 때 비효울적이라는 점이다.
- 왜냐하면 배열에 존재하는 원소의 갯수를 기록해주기 위해선 크키가 원소의 최댓값인 count 배열을 만들어 주어야 하기 때문이다.
- 또 배열의 인덱스를 통해 숫자를 세어주는 방식이기 때문에, 만일 배열에 음수가 존재한다면 사용할 수 없다.


- 배열의 크기가 100만인데 과연 계수정렬을 사용하는 것이 효율적인 코딩인지, 어느부분에서 메모리 절약이 되었는지 잘 모르겠다.
- 수현이는 힙정렬을 사용해보라고 해서 힙정렬에 대해 조사를 해봐야겠다.



