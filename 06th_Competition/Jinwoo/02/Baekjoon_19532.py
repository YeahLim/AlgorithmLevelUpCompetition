'''
# ZeroDivisionError 오류 코드
import sys

a, b, c, d, e, f = map(int, sys.stdin.readline().split())

y = ((a * f) - (d * c)) // ((a * e) - (d * b))
x = (c - (b * y)) // a

print(int(x), int(y))
'''

'''
# 위 문제풀이와 풀이방법은 동일하나 왜 이 방법은 되고 위에 방법은 안되는지 모르겠음....
import sys
a, b, c, d, e, f = map(int, sys.stdin.readline().split())

print((c*e-b*f)//(a*e-b*d), (a*f-d*c)//(a*e-b*d))
'''

# 시간이 훨씬 더 소요되는 모든 경우의 수를 찾는 브루트 포스 문제풀이 방법
import sys

a, b, c, d, e, f = map(int, sys.stdin.readline().split())

문자열 11의 길이를 split함수를 이용해서 변수 6개에 넣는 행위
1 2 3 4 5 6
=> (모든 문자를 탐색) + (공백이 나오면 변수에 저장) + (각각의 입력값을 int형으로 변환)
=> 11 + 5 + 6
=> 22

문자열 35의 길이를 split함수를 이용해서 변수 6개에 넣는 행위
10000 20000 30000 40000 50000 60000
=> (모든 문자를 탐색) + (공백이 나오면 변수에 저장) + (각각의 입력값을 int형으로 변환)
=> 35 + 5 + 6
=> 46

문자열 100만개 길이를 split함수를 이용해서 변수 6개에 넣는 행위

=> (모든 문자를 탐색) + (공백이 나오면 변수에 저장) + (각각의 입력값을 int형으로 변환)
=> 100만 + 5 + 6
=> 100만 + 11

문자열 N개 길이를 split함수를 이용해서 변수 6개에 넣는 행위
=> (모든 문자를 탐색) + (공백이 나오면 변수에 저장) + (각각의 입력값을 int형으로 변환)
=> N + 5 + 6
=> N + 11


for x in range(-999,1000):
1999 + 1999
=> 3998
    for y in range(-999,1000):
    1999 + 1999
    => 3998
           if ((((a*x) + (b*y)) == c) and (((d*x) + (e*y) == f))):
               print(x, y)
            => 4

=> 3998 * 3998 * 4 (상수)


전체 시간 복잡도 = N +11 + 3998 * 3998 * 4
 = O(N)
 N = 29
=> 예상되는 연산횟수 => O(N) => N => 900만

(파이썬 기준으로)1초 => 1000만번

