# [백준 - 실버 1] 회전 초밥 (2531 번)

## ⏰  **time**

1시간

## :pushpin: **Algorithm**

- 정렬
- 두 포인터
- 슬라이딩 윈도우

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 회전 초밥 벨트에 N개의 접시가 놓여져 있음
- d 개의 초밥의 종류가 있음
- k개로 연속으로 초밥을 먹을 때 먹을 수 있는 초밥의 최대 종류 개수를 구하는 문제.
- 예외가 있다면 쿠폰을 사용하여 먹을 수 있다는 점 (그래서 사실 최대 초밥수는 K + 1 이다.)
- 슬라이드 윈도우를 사용하여 시간복잡도를 O(N)으로 단축시킴
- 딕셔너리를 구성하여 현재 슬라이드 윈도우 안에 있는 초밥의 종류를 세주었다.
- 초밥의 종류만 count를 하였고 중복되는 값은 기록하지 않았다.
- 윈도우를 이동할 때 윈도우 왼쪽의 초밥을 제거, 새로운 초밥을 등록시킨다.
- 만일 이미 슬라이드 윈도우에 있는 초밥 종류일 경우는 등록하지 않는다.
- 매번 슬라이드 윈도우의 초밥 종류 최댓값을 갱신
- 반복문을 전부 돌려 회전 초밥 벨트를 한바퀴 돌았다면 그때 초밥의 최대값을 출력하면 된다.

## :black_nib: **Review**

### 첫번째 시행 착오 (두 포인터 사용)

```python
import sys
input = sys.stdin.readline

# N: 회전 초밥 벨트에 놓인 접시의 수
# d: 초밥의 가짓수
# k: 연속해서 먹는 접시의 수
# coupon_num: 쿠폰 번호
N, d, k, coupon_num = map(int, input().split())

sushi_list = [int(input()) for _ in range(N)]
# print(susi_list)

result = []

# 회전 초밥 벨트중 연속해서 먹을 수 있는 초밥들의 경우의 수 탐색
for start in range(N):
    # 연속해서 먹을 초밥들을 담을 리스트
    temp = []

    # 두 포인터
    # 연속해서 먹을 초밥 접시의 인덱스 시작값을 늘려가며 탑색
    # 끝 인덱스가 초밥 배열 인덱스가 초가되는 경우가 있으므로
    # 접시의 수로 나눈 나머지 값을 통해 7번 끝에서 다음 0번 인덱스의 값을 탐색할 수 있도록 구현
    for j in range(start, start + k):
        temp.append(sushi_list[j % N])

        # 쿠폰 값 초밥도 추가
        temp.append(coupon_num)

    # print(temp)
    # 초밥종류의 중복값을 제거
    result.append(len(set(temp)))

# 먹을 수 있는 초밥 가짓수 최댓값 출력
print(max(result))
```
- 시간 초과 오류가 발생
- 연속된 k개의 초밥을 매번 새롭게 리스트로 생성하여 중복을 제거하고,
- 이를 `result.append(set(temp)))` 로 저장을 함.
- 매번 set(temp)를 사용해 중복을 제거하는 과정에서 O(k)연산이 반복
- 따라서 O(N*k) 연산이 반복이 되며, 최악의 경우 O(N^2)의 시간복잡도가 발생하게 됨.

### 개선점: 슬라이딩 윈도우 사용
- 두 포인터는 그 길이가 유동적이지만 슬라이딩 윈도우는 유동적이지 않고 고정되어 있다.
- 즉, 윈도우의 크기를 지정해두고 그 윈도우 자체를 슬라이딩 하는 개념이다.

