# [백준 - 실버 3] 시리얼 번호  (1431 번)

## ⏰  **time**

50분

## :pushpin: **Algorithm**

- 정렬

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

### 문제조건
- A와 B의 길이가 다르면, 짧은 것이 먼저 온다. 
- 만약 서로 길이가 같다면, A의 모든 자리수의 합과 B의 모든 자리수의 합을 비교해서 작은 합을 가지는 것이 먼저온다. (숫자인 것만 더한다)
- 만약 1,2번 둘 조건으로도 비교할 수 없으면, 사전순으로 비교한다. 숫자가 알파벳보다 사전순으로 작다.

### 풀이
- datasum리스트에 각 단어의 숫자합을 넣고, 위 3가지 정렬 조건을 sort함수의 key인자에 람다함수를 넣어 정렬

## :black_nib: **Review**

- 람다함수를 활용하여 2차배열에서 인덱스를 기준으로 정렬을 할 수 있었다.

### 람다함수를 활용한 정렬
```commandline
test = [(1, 8), (2, 3), (7, 9), (6, 1), (4, 5), (1, 5)]
# x[]을 기준으로 오름차순 정렬하고 x[이값이 같다면 x[1]을 기준으로 정렬 print(sorted(test, key = lambda x : (x[0], x[1])))
# [(1, 5), (1, 8), (2, 3), (4, 5), (6, 1), (7, 9)]
# x[]을 기준으로 오름차순 정렬하고 x[]값이 같다면 -x[1]을 기준(x[1]의 내림차순으로 정렬 print(sorted(test, key = lambda x : (x[0], -x[1])))
# [(1, 8), (1, 5), (2, 3), (4, 5), (6, 1), (7, 9)]
```