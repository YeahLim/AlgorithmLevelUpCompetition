# [백준 - 실버 2] DFS와 BFS (1260 번)

## ⏰  **time**

1 시간 이상

## :pushpin: **Algorithm**

- 그래프 이론 
- 그래프 탐색 
- 너비 우선 탐색 
- 깊이 우선 탐색

## ⏲️**Time Complexity**

$O(N^2)$

## :round_pushpin: **Logic**

- 이번 문제를 풀이하기 위해 행렬을 만들어야 했다.
- 개념이 어려워 행렬을 만드는 법을 찾아보았다.

### 리스트 컴프리헨션으로 행렬 만들기
```commandline
graph = [[0]*(N+1) for _ in range(N+1)]
for i in range (M):
    a,b = map(int,input().split())
    graph[a][b] = graph[b][a] = 1
```
- [[0]*(N+1)] 은 N이 3이라면 [[0,0,0,0]]을 출력 합니다. 
- 리스트 컴프리헨션을 써주면 [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]행렬이 완성이 되게 됩니다.

### DFS 구현해보기

- 현재 정점 V를 방문처리 하고, V를 출력합니다.
- V와 연결된 정점을 변호가 작은 순서부터 방문해야 하며, 연결된 정점 중 방문하지 않은 정점에 대해 재귀 호출을 하게 하였습니다.

### 큐를 활용한 BFS 구현해보기

- 큐를 활용하여 현재 점점 V를 탐색하였습니다.
- 큐에서 정점을 꺼내 V를 출력하고, V와 연결된 정점 중 방문하지 않은 점점을 큐에 추가할 수 있었습니다.

## :black_nib: **Review**

- BFS, DFS 개념을 파악할 수 있었습니다.
- 여태 배운 알고리즘 개념들 중에 제일 어려운듯...