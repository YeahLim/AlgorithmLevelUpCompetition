# [백준 - 실버 1] RGB거리 (1149 번)

## ⏰  **time**

1시간

## :pushpin: **Algorithm**

- 다이나믹 프로그래밍

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- 칠해야 하는 집의 수: `N`이 주어지고 1번부터 N번 집까지 RGB로 칠해야 한다.
- 다음엔 RGB로 칠하는 비용이 주어지고 아래 조건을 만족하며 모든 집을 칠하는 최소값을 구하는 문제이다.

### 조건
- 1번 집의 색은 2번 집의 색과 같지 않아야 한다. 
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다. 
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

### 점화식 세워보기
```commandline
    for j in range(1, N+1):
    dp[j][0] = min(dp[j-1][1], dp[j-1][2]) + cost[j][0]
    dp[j][1] = min(dp[j-1][0], dp[j-1][2]) + cost[j][1]
    dp[j][2] = min(dp[j-1][0], dp[j-1][1]) + cost[j][2]
```
- 우선 RGB 색으로 집을 칠하는 비용값들을 cost 리스트에 2차원 배열로 넣어준다.
- 그리고 dp 배열도 2차원 배열로 초기화 시켜주었다.
- 위 점화식은 i번째 집을 칠할 때 i-1과 i+1과 색이 겹치면 안되기 때문에
- i번째에서 0번째(빨강), 1번째(파랑), 2번째(초록)이 선택 되었을 때, 현재 선택한 색을 뺀 경우(현재 집을 빨강으로 칠할 경우 이전 집은 초록, 파랑중 최솟값을 선택)와
- 현재 칠한 값을 더해준다. 그리고 이것을 `dp[j][0, 1, 2]`에 저장한다.
- 이렇게 되면 현재의 선택에 따른 최솟값들을 현재 dp 배열에 담을수가 있으며, 이중에서 최솟값을 선택하는 경우 `min(dp[N][:3])`이 모든 집을 칠하는 최솟값이 되는 것이다.

## :black_nib: **Review**

- 배열을 2개 사용햐여 풀었으나, 하나만 써서 풀은 사람도 있었다.
- dp배열과 cost배열이 중간에 헷갈려서 풀이가 오래 걸렸다...