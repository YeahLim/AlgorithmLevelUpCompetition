# [백준 - 실버 3] 구간 합 구하기 4 (11659 번)

## ⏰  **time**

40분

## :pushpin: **Algorithm**

누적합

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- N개의 숫자 배열에서 i ~ j 범위를 입력받고 그 사이 숫자들의 누적합을 구하는 문제이다.
- 그래서 누적합 리스트 sum_list를 따로 만들어 거기에 첫번째부터 N번쩨 까지의 숫자 합을 넣었다.
- 0번째는 없으므로 인덱스[0] 자리엔 0을 집어 넣어줬다. 이렇게 되면 j - (i-1)을 할 때 편리하다.
- 그래서 i, j 범위를 입력 받게 되면 sum_list[j] - sum_list[i-1]를 출력하여 문제풀이를 진행하였다.

## :black_nib: **Review**

- 누적합을 구하는 이번 문제 풀이는 i부터 j까지의 합을 구하는 문제이다.
- 이것만 보면 보통 다음과 같이 풀이할 것이다.

```commandline
import sys

N, M = map(int, input().split())                                                    # N의 개수, 합을 구해야 하는 회수 M
N_list = list(map(int, sys.stdin.readline().split()))

#print(N, M)
#print(N_list)

for _ in range(M):
    i, j = map(int, sys.stdin.readline().split())
    x = 0
    for k in range(i-1,j):
        x += N_list[k]
    print(x)
```

- 하지만 이렇게 풀면 시간복잡도가 O(N^2)가 나와버린다.
- 다른 방법이 뭐가 있을지 생각해본다... 

- i~j를 제외한 배열의 인덱스를 하나씩 제거 후 sum()으로 풀어야 하나? -> sum()도 시간복잡도가 O(N)이라 반복문 안에서는 사용이 불가능하다...
- 입력을 여러번 받으므로 전 입력시 합한 정보를 저장해놨다 다음 범위에 포함될 경우 사용해야 하나? -> 구현해야할 방법을 모르겠다.. 하지만 이 방법이 시간 복잡도를 줄이는 유일한 방법일거 같기도 하다... 하지만 경우의 수가 너무 많다.
- 고민을 거듭한 결과 내가 날짜 사이의 일수를 구할때 [마지막 날] - ([첫날] - 1) 이렇게 구한다는것을 생각했고 이 방법을 통해 구해볼 수 있을까 생각을 했다.
- 그 결과 누적합 리스트를 따로 만들어 인덱스 값을 j - (i-1)을 해주면 누적합을 구할 수 있다는 것을 깨닳았다. 
