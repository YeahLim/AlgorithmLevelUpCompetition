# [백준 - 실버 1] 단지번호붙이기 (2667 번)

## ⏰  **time**

1시간 이상

## :pushpin: **Algorithm**

- 그래프 이론
- 그래프 탐색
- 너비 우선 탐색
- 깊이 우선 탐색

## ⏲️**Time Complexity**

$O(N^2)$

## :round_pushpin: **Logic**

- 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타내는 N x N 의 지도(행렬)이 주어집니다.
- 연결된 집의 모임 단지를 지정하여 단지가 몇 개인지, 한 단지당 몇개의 집이 있는지 오름차순로 출력하는 문제입니다.
- 이런 bfs, dfs를 풀때는 노드정보와 간선 정보를 정의하는게 중요하다고 생각이 들었습니다.
- 여기서의 노드 정보는 **현재 행렬의 좌표값** 이라 할 수 있겠고 간선 정보는 **주변에 1칸씩 떨어져 있는 `1` 의 좌표값**라 할 수 있습니다.

### 지도에서 상,하,좌,우로 근처 집 탐색해보기
```commandline
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

for i in range(4):  # 상하좌우 살피기
    nx = x + dx[i]
    ny = y + dy[i]
```
- dfs, bfs 알고리즘 모두 **(1)인접한 노드인지**, **(2)방문한 적이 있는 노드인지**를 확인을 해야 합니다.
- 위와 같이 변수를 선언해준 후 반복문을 돌려주면 상,하,좌,우로 1칸씩 탐색을 할 수 있게 됩니다.

### bfs 풀이방법

- 우선 행렬의 0,0부터 n,n까지 이중 반복문으로 탐색을 시작합니다.
- 반복문에 조건을 걸어 `if graph[i][j] == 1` 현재 좌표 값이 `1` 일때 bfs 함수를 실행합니다.
- bfs 함수는 현재 좌표값 `i, j`를 queue에 넣어줍니다.
- 그리고 현재 좌표값을 0으로 만들어 줍니다.
- 여기 까지가 진입점이고 이제 while 반복문을 통해 
  - 진입점의 좌표를 꺼내 현재 좌표(노드) `x, y`입력 
  - `x, y`와 연결되어 있는 1의 좌표 정보를 for문으로 탐색
  - 조건에 해당되는 좌표 정보를 queue에 추가, count 증가
- 위 순서를 밟으면 해당 아파트 단지의 집의 개수를 전부 count 하고 0으로 지워 방문 처리를 하게 됩니다.
- 이것을 N x N 행렬에서 탐색을 해주면 모든 단지를 탐색할 수 있게 됩니다.

### dfs 풀이방법

- bfs랑 조금 다릅니다.
- 행렬의 0,0 부터 n,n 까지 이중 반복문으로 탐색을 하되 이번엔 `if graph[i][j] == 1` 조건이 dfs() 함수 안에 있습니다.
- 즉 이중반복문 마다 dfs() 함수가 실행되고 `if graph[i][j] == 1` 조건이 아닐 경우는 False를 반환, 조건에 해당될 경우 Ture 를 반환하여 진행합니다.
- 함수 진입점에서 현재 좌표 `i, j` 방문처리`graph[x][y] = 0`후 
- 인접한 곳에 집이 있다면 해당 좌표로 dfs(nx, ny)를 또 실행하게 됩니다. (재귀함수)
- 이것도 N x N 행렬에서 탐색을 해주면 모든 단지를 탐색할 수 있게 됩니다.

### 지도밖 예외처리
```commandline
    if x < 0 or x >= N or y < 0 or y >= N:
```
- 탐색할때 행렬을 빠져 나가게 되는 경우를 다음 조건으로 예외처리 하였습니다.

## :black_nib: **Review**

- 풀이 할 때 지도에 있는 집 정보를 탐색하면 N x N의 시간 복잡도가 발생 하고, 거기에 dfs, bfs 함수까지 돌릴 경우 시간 복잡도가 더해진다.
- 그래서 시간초과가 되지 않을까? 라는 우려를 했던것 같다. (입력값이 작아서 다행)

### dfs vs bfs
- 단지를 탐색할 때는 dfs보단 bfs가 여러 단지를 동시에 탐색을 하기 때문에 더 직관적이고 적합하다는 생각이 들었다. 
- dfs는 N 값이 커지면 재귀 제한이 걸릴 수 있다고 한다. 이러한 경우를 스택 오버플로우 위험 이라고 한다.
- bfs는 N 값이 커질 경우 추가 메모리를 사용을 하여 메모리 초과 문제를 생각해야 한다.
- bfs는 최단거리를 구하거나 모든 노드를 동등하게 탐색해야 할 때 사용이 용이하다.