# [백준 - 골드 5] 수 고르기 (2230 번)

## ⏰  **time**

1시간 30분

## :pushpin: **Algorithm**

정렬
두 포인터

## ⏲️**Time Complexity**

$O(N)$

## :round_pushpin: **Logic**

- N만큼의 수열의 값을 입력 받은 후
- 두 수의 차이가 M 이상 이면서 제일 작은 수의 경우를 구하는 문제입니다.
- 따라서 두 포인터를 지정하여 
- 두 수의 차이가 M 미만일 경우에는
- 두 수의 차이가 M보다 큰 경우를 찾아야 하므로 오른쪽 포인터를 1 증가 시키고
- 두 수의 차이가 M보다 크거나 같을 경우의 경우는
- 기존의 결과와 비교하여 최솟값이면 업데이트를 시켜
- 결과적으로 min_result에 최솟값이 들어가여 출력을 하도록 풀이를 진행 하였습니다.

## :black_nib: **Review**

- 처음 풀이를 진행 할 땐 두 포인터를 왼쪽 끝과 오른쪽 끝에 놓아 풀이를 진행하였습니다.
- 하지만 이럴 경우 오른쪽 포인터가 왼쪽부터 오른쪽으로 시작하는 것보다 훨씬 더 많은 경우의 수를 계산을 해야 했으며
- 결국 이 풀이 방법은 시간초과로 이어졌습니다.
- 이것을 해결하기 위해 오른쪽 포인터의 시작을 왼쪽으로 옮겼으며
- 비교할 결과값의 초기값을 sys.maxsize를 통해 정수의 최댓값을 넣어주었고
- 그 다음 조건에 부합하는 값이 나올때 마다 비교하여 최솟값을 출력하도록 풀이를 진행하였습니다.